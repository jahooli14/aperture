-- Migration: Add Connections Table and Project Priority Field
-- Description: Implements explicit linking between all content types (Sparks)
-- Created: 2025-10-28

-- ============================================================================
-- TABLE: connections
-- Explicit links between any content types (Projects, Thoughts, Articles, Suggestions)
-- This is the "Sparks" system - making linking a first-class citizen
-- ============================================================================

CREATE TABLE IF NOT EXISTS connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Source and target can be any content type
  source_type TEXT NOT NULL CHECK (source_type IN ('project', 'thought', 'article', 'suggestion')),
  source_id UUID NOT NULL,
  target_type TEXT NOT NULL CHECK (target_type IN ('project', 'thought', 'article', 'suggestion')),
  target_id UUID NOT NULL,

  -- Connection metadata
  connection_type TEXT NOT NULL DEFAULT 'relates_to' CHECK (
    connection_type IN ('inspired_by', 'relates_to', 'evolves_from', 'ai_suggested', 'manual', 'reading_flow')
  ),

  -- AI reasoning (when created by AI)
  ai_reasoning TEXT,

  -- Tracking
  created_by TEXT NOT NULL DEFAULT 'user' CHECK (created_by IN ('ai', 'user', 'system')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),

  -- Prevent duplicate connections (same source->target pair)
  CONSTRAINT unique_connection UNIQUE (source_type, source_id, target_type, target_id)
);

CREATE INDEX idx_connections_source ON connections(source_type, source_id);
CREATE INDEX idx_connections_target ON connections(target_type, target_id);
CREATE INDEX idx_connections_created_by ON connections(created_by);
CREATE INDEX idx_connections_type ON connections(connection_type);
CREATE INDEX idx_connections_created_at ON connections(created_at DESC);

COMMENT ON TABLE connections IS 'Explicit bidirectional links between all content types (Sparks system)';
COMMENT ON COLUMN connections.source_type IS 'project = projects table, thought = memories table, article = reading_queue table, suggestion = project_suggestions table';
COMMENT ON COLUMN connections.connection_type IS 'inspired_by = source inspired target, relates_to = general relation, evolves_from = target is evolution of source, ai_suggested = AI found this link, manual = user created, reading_flow = auto-created from reading->thought';
COMMENT ON COLUMN connections.created_by IS 'ai = generated by synthesis, user = manually created, system = auto-created (e.g., reading flow)';

-- Enable RLS (open for single-user, ready for multi-user future)
ALTER TABLE connections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all connections"
  ON connections FOR SELECT USING (true);

CREATE POLICY "Users can insert connections"
  ON connections FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can delete connections"
  ON connections FOR DELETE USING (true);

-- ============================================================================
-- EXTEND: projects table
-- Add priority field for "Active Project Steps" homepage module
-- ============================================================================

-- Add priority column if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'projects' AND column_name = 'priority'
  ) THEN
    ALTER TABLE projects ADD COLUMN priority BOOLEAN DEFAULT false;
    CREATE INDEX idx_projects_priority ON projects(priority) WHERE priority = true;
  END IF;
END $$;

COMMENT ON COLUMN projects.priority IS 'True if this project should appear in Active Project Steps on homepage';

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

-- Function to get all connections for a given item
CREATE OR REPLACE FUNCTION get_item_connections(
  item_type TEXT,
  item_id UUID
)
RETURNS TABLE (
  connection_id UUID,
  related_type TEXT,
  related_id UUID,
  connection_type TEXT,
  direction TEXT, -- 'outbound' or 'inbound'
  created_by TEXT,
  created_at TIMESTAMP WITH TIME ZONE,
  ai_reasoning TEXT
) AS $$
BEGIN
  RETURN QUERY
  -- Outbound connections (this item is the source)
  SELECT
    c.id,
    c.target_type,
    c.target_id,
    c.connection_type,
    'outbound'::TEXT,
    c.created_by,
    c.created_at,
    c.ai_reasoning
  FROM connections c
  WHERE c.source_type = item_type AND c.source_id = item_id

  UNION ALL

  -- Inbound connections (this item is the target)
  SELECT
    c.id,
    c.source_type,
    c.source_id,
    c.connection_type,
    'inbound'::TEXT,
    c.created_by,
    c.created_at,
    c.ai_reasoning
  FROM connections c
  WHERE c.target_type = item_type AND c.target_id = item_id

  ORDER BY created_at DESC;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION get_item_connections IS 'Returns all connections for an item (both inbound and outbound)';

-- Function to get thread (recursive connections)
CREATE OR REPLACE FUNCTION get_item_thread(
  item_type TEXT,
  item_id UUID,
  max_depth INTEGER DEFAULT 10
)
RETURNS TABLE (
  item_type TEXT,
  item_id UUID,
  depth INTEGER
) AS $$
WITH RECURSIVE thread AS (
  -- Start with the root item
  SELECT
    item_type AS item_type,
    item_id AS item_id,
    0 AS depth

  UNION

  -- Recursively find connected items
  SELECT
    CASE
      WHEN c.source_type = t.item_type AND c.source_id = t.item_id
      THEN c.target_type
      ELSE c.source_type
    END,
    CASE
      WHEN c.source_type = t.item_type AND c.source_id = t.item_id
      THEN c.target_id
      ELSE c.source_id
    END,
    t.depth + 1
  FROM thread t
  JOIN connections c ON
    (c.source_type = t.item_type AND c.source_id = t.item_id) OR
    (c.target_type = t.item_type AND c.target_id = t.item_id)
  WHERE t.depth < max_depth
)
SELECT DISTINCT item_type, item_id, MIN(depth) as depth
FROM thread
GROUP BY item_type, item_id
ORDER BY depth, item_type, item_id;
$$ LANGUAGE sql;

COMMENT ON FUNCTION get_item_thread IS 'Returns all items in the thread (connected graph) starting from a given item';

-- ============================================================================
-- DATA MIGRATION
-- Migrate existing source_reference data to connections table
-- ============================================================================

DO $$
DECLARE
  memory_record RECORD;
  source_ref JSONB;
BEGIN
  -- Migrate memories with source_reference to connections
  FOR memory_record IN
    SELECT id, source_reference
    FROM memories
    WHERE source_reference IS NOT NULL
  LOOP
    source_ref := memory_record.source_reference;

    -- Create connection from source to this memory
    IF source_ref->>'type' IS NOT NULL AND source_ref->>'id' IS NOT NULL THEN
      INSERT INTO connections (
        source_type,
        source_id,
        target_type,
        target_id,
        connection_type,
        created_by
      )
      VALUES (
        source_ref->>'type',
        (source_ref->>'id')::UUID,
        'thought',
        memory_record.id,
        'inspired_by',
        'system'
      )
      ON CONFLICT (source_type, source_id, target_type, target_id) DO NOTHING;
    END IF;
  END LOOP;

  RAISE NOTICE 'Migrated existing source_reference data to connections table';
END $$;

-- ============================================================================
-- SUCCESS MESSAGE
-- ============================================================================

DO $$
BEGIN
  RAISE NOTICE 'âœ“ Migration 006 complete: Connections table created, priority field added';
  RAISE NOTICE '  - connections table: Explicit linking between all content types';
  RAISE NOTICE '  - projects.priority: Boolean field for homepage Active Project Steps';
  RAISE NOTICE '  - Helper functions: get_item_connections(), get_item_thread()';
  RAISE NOTICE '  - Data migrated from memories.source_reference to connections';
END $$;
